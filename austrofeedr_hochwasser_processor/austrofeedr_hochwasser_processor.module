<?php

// Drupal needs this blank file.

/**
 * Implements hook_rules_action_info().
 */
function austrofeedr_hochwasser_processor_rules_action_info() {
  return array(
    'hw_wasserstand_update' => array(
      'base' => 'hw_wasserstand_update_status_action',
      'label' => t('Hochwasser Wasserstand update status'),
      'group' => t('AustroFeedr'),
      'parameter' => array(
        'pegelaktuell_item' => array('type' => 'wsclient_hw_pegelaktuell_ehyd_service_pegelaktuell', 'label' => t('Pegelaktuell item')),
        'messstelle' => array('type' => 'node', 'label' => t('Messstelle')),
      ),
      'provides' => array(
        'hw_status_term' => array('type' => 'taxonomy_term', 'label' => t('Hochwasser status term')),
      ),
    ),
    'hw_wasserstand_update_trend' => array(
      'base' => 'hw_wasserstand_update_trend_action',
      'label' => t('Hochwasser Wasserstand update trend'),
      'group' => t('AustroFeedr'),
      'parameter' => array(
        'pegelaktuell_item' => array('type' => 'wsclient_hw_pegelaktuell_ehyd_service_pegelaktuell', 'label' => t('Pegelaktuell item')),
        'messstelle' => array('type' => 'node', 'label' => t('Messstelle')),
      ),
      'provides' => array(
        'hw_trend_term' => array('type' => 'taxonomy_term', 'label' => t('Hochwasser trend term')),
      ),
    ),
    'hw_messstelle_update' => array(
      'base' => 'hw_messstelle_update_action',
      'label' => t('Hochwasser Messstelle update'),
      'group' => t('AustroFeedr'),
      'parameter' => array(
        'pegelaktuell_item' => array('type' => 'wsclient_hw_pegelaktuell_ehyd_service_pegelaktuell', 'label' => t('Pegelaktuell item')),
        'messstelle' => array('type' => 'node', 'label' => t('Messstelle')),
      ),
    ),
    'hw_get_wasserstand_unbestimmt' => array(
      'base' => 'hw_get_wasserstand_unbestimmt_action',
      'label' => t('Hochwasser Wasserstand Unbestimmt get term'),
      'group' => t('AustroFeedr'),
      'parameter' => array(),
      'provides' => array(
        'hw_unbestimmt_term' => array('type' => 'taxonomy_term', 'label' => t('Hochwasser unbestimmt status term')),
      ),
    ),
  );
}

/**
 * Rules action for Hochwasser Wasserstand update status.
 */
function hw_wasserstand_update_status_action($pegelaktuell_item, $messstelle) {

  // Require all necessary fields to be set.
  if(!(isset($pegelaktuell_item['wert'])
   && isset($messstelle->field_hw_wert_mq['und'])
   && isset($messstelle->field_hw_wert_mjnq['und'])
   && isset($messstelle->field_hw_wert_hq1['und'])
   && isset($messstelle->field_hw_wert_hq10['und'])
   && isset($messstelle->field_hw_wert_hq30['und']))) {
    return array();
  }

  // Extract necessary fields.
  $wert = $pegelaktuell_item['wert'];
  $mq   = $messstelle->field_hw_wert_mq['und'][0]['value'];
  $mjnq = $messstelle->field_hw_wert_mjnq['und'][0]['value'];
  $hq1  = $messstelle->field_hw_wert_hq1['und'][0]['value'];
  $hq10 = $messstelle->field_hw_wert_hq10['und'][0]['value'];
  $hq30 = $messstelle->field_hw_wert_hq30['und'][0]['value'];

  // Hochwasserstand interpretation.
  if($wert > $hq30) {
    $status = 'Hochwasserstufe 3';
  }
  else if($wert > $hq10) {
    $status = 'Hochwasserstufe 2';
  }
  else if($wert > $hq1) {
    $status = 'Hochwasserstufe 1';
  }
  else if($wert > ($hq1 + $mq) / 2) {
    $status = 'erhöhte Wasserführung';
  }
  else if($wert > ($mq + $mjnq) / 2) {
    $status = 'Mittelwasser';
  }
  else{
    $status = 'Niederwasser';
  }

  // Map status to taxonomy term.
  $terms = (taxonomy_get_term_by_name(t($status)));
  $status_term = array_shift($terms);

  if(isset($messstelle->field_hw_status['und']) && isset($messstelle->field_hw_status['und'][0])) {
      $old_status_term = taxonomy_term_load($messstelle->field_hw_status['und'][0]['tid']);
  }

  /* don't send message, but change messstelle itself
  // Send warn message if status changed from below Hochwasser to above Hochwasser.
  if((strpos($status_term->name, 'Hochwasser') === 0) &&
     (!isset($old_status_term) || strpos($old_status_term->name, 'Hochwasser') === false))
  {
    $node = new stdClass();
    $node->field_hw_messstelle = array('und' => array(0 => array('nid' => $messstelle->nid)));
    $node->field_hw_status_neu = array('und' => array(0 => array('tid' => $status_term->tid)));
    if(isset($old_status_term)) {
      $node->field_hw_status_alt = array('und' => array(0 => array('tid' => $old_status_term->tid)));
    }
    $node->title = $status_term->name . ' ' . $messstelle->title;
    $node->type = "hochwasser_update";
    node_save($node);
    //$message->save();
  }
  */

  $messstelle_name = $messstelle->field_hw_gewaesser['und'][0]['value'] . ' / ' . $messstelle->field_hw_name['und'][0]['value'];

  if((strpos($status_term->name, 'Hochwasser') === 0))
  {
    // Neue Hochwassermeldung falls notwendig.
    if(!isset($old_status_term) || strpos($old_status_term->name, 'Hochwasser') === false)
    {
      $messstelle->title = $status_term->name . ': ' . $messstelle_name;
      $messstelle->created = time();
      // Hochwassermeldung Tag setzen.
      $messstelle->field_update_tags = array('und' => array(0 => array('tid' => 217)));
    }
  }
  else {
    // Ggf. alte Meldung zurücksetzen.
    if(isset($old_status_term) && strpos($old_status_term->name, 'Hochwasser') !== false) {
      $messstelle->title = $messstelle_name;
      $messstelle->field_update_tags = array();
      $messstelle->created = time();
      // todo: only set timestamp when changing state
      //$node->changed = time();
    }
  }

  return array('hw_status_term' => $status_term->tid);
}

/**
 * Rules action for Hochwasser Wasserstand update trend.
 */
function hw_wasserstand_update_trend_action($pegelaktuell_item, $messstelle) {
  // Require all necessary fields to be set.
  if(!(isset($pegelaktuell_item['wert'])
   && isset($messstelle->field_hw_werte['und'])
   && (count($messstelle->field_hw_werte['und']) > 1))) {
    return array();
  }

  // Extract necessary fields.
  $wert = $pegelaktuell_item['wert'];
  $index = count($messstelle->field_hw_werte['und']) - 2;
  $old = $messstelle->field_hw_werte['und'][$index]['value'];

  // Hochwasserstand interpretation.
  if($wert > $old) {
    $trend = 'steigend';
  }
  else if($wert == $old) {
    $trend = 'gleichbleibend';
  }
  else {
    $trend = 'fallend';
  }

  // Map status to taxonomy term and return.
  $terms = (taxonomy_get_term_by_name(t($trend)));
  $status_term = array_shift($terms);

  return array('hw_trend_term' => $status_term->tid);
}

/**
 * Rules action for Hochwasser Messstelle update.
 */
function hw_messstelle_update_action($pegelaktuell_item, $messstelle) {
  $wrapper = entity_metadata_wrapper('node', $messstelle);

  $wrapper->field_hw_parameter = $pegelaktuell_item['parameter'];
  $wrapper->field_hw_gewaesser = $pegelaktuell_item['gewasser'];
  $wrapper->field_hw_link->set(array('url' => $pegelaktuell_item['internet']));

  // Einheit definiert durch parameter.
  if($pegelaktuell_item['parameter'] == 'W') {
    $wrapper->field_hw_einheit = 'cm';
  }
  else if($pegelaktuell_item['parameter'] == 'Q') {
    $wrapper->field_hw_einheit = 'm³/s';
  }

  // Title should be 'Messstellenname / Gewässer'.
  if(strpos($pegelaktuell_item['messstelle'], $pegelaktuell_item['gewasser']) === FALSE) {
    $wrapper->title = $pegelaktuell_item['messstelle'] . ' / ' . $pegelaktuell_item['gewasser'];
  }
  else {
    $wrapper->title = $pegelaktuell_item['messstelle'];
  }

  entity_save('node', $wrapper);
  return;
}

/**
 * Rules action for Hochwasser Wasserstand Unbestimmt get term.
 */
function hw_get_wasserstand_unbestimmt_action() {
  // Map Unbestimmt to taxonomy term and return.
  $terms = (taxonomy_get_term_by_name(t('Unbestimmt')));
  foreach($terms as $term) {
    if($term->vocabulary_machine_name == 'hw_status') {
      return array('hw_unbestimmt_term' => $term->tid);
    }
  }
}